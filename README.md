# Language experiments

Some experiments implementing the same simple applications in different languages.
The goal of these experiments is to explore the tooling for the various language ecosystems, rather than the 
capabilities of the languages themselves.

The CLI application is a simple `grep` implementation. It uses an external args parsing library and the stdlib.

# Rust

## CLI application

Setting up the environment:

```shell
> curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Creating a new application:

```shell
> cargo new cli-app
```

This creates a very minimal 'hello world' CLI app.

The application can be run using:

```shell
> cargo run <pattern> <file>
```

Adding a dependency:

```shell
> cargo add clap --features derive
```

This adds the most recent stable version of the dependency to the model.

The quickstart guide did not include the `--features` flag and so compilation failed.

### Notes

- The new application generated by `cargo new` is the minimum to get started and so there is no noise.
- Uses `crates.io` repository by default for resolving dependencies and publishing.
  - Not having to define this reduces noise.
- Project dependencies are declared using a path and the module does not need to be added to a workspace.
  - This reduces noise.
- Unit test are mixed into the production source.

### TODO
- Add a library to the CLI app
- Use a workspace
- Use multiple targets and target dependent dependencies and source
- What happens when adding a dependency in a workspace?
- Add integration tests
- Add some features
- Add documentation
- Implement a web app
- Go, KMP, Haskell, node.js, Java, C#, python, ruby
